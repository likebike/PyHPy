#!/usr/bin/env python

# This script publishes the input directory to the output directory in an intelligent
# way.  Copies file data & permissions & ACLs, evaluates Mako templates, ignores
# hidden files.
#
# Written by Christopher Sebastian, 2011-11-04.  Redesigned 2016-03-01.

import os, sys, fnmatch, re, subprocess
import pyhpy.sync

## NOT_SKIP_GLOBS=['.htaccess*', '.htpasswd*']  # Hidden files that we actually want to process.
## SKIP_GLOBS=['.*', '_*', '*~', '*.swp', '*.pyc', '*.meta', '*.mako.py']
## 
## def isHiddenFile(Filename):
##     filename = Filename.lower()
##     for pat in NOT_SKIP_GLOBS:
##         if fnmatch.fnmatchcase(filename, pat): return False
##     for pat in SKIP_GLOBS:
##         if fnmatch.fnmatchcase(filename, pat): return True
##     return False
## 
## def hiddenFileHandler(data, DST_DIR, okDstFiles):
##     #print 'Skipping hidden file:',data['urlPath']
##     pass
## def fileOrSymlinkHandler(data, DST_DIR, okDstFiles):
##     dstPath = os.path.join(DST_DIR, data['relPath'])
##     pyhpy.sync.syncFileOrSymlink(data['absPath'], dstPath)
##     okDstFiles.append(dstPath)
## def makoFileHandler(data, DST_DIR, okDstFiles):
##     relBase, relExt = os.path.splitext(data['relPath'])
##     assert relExt.lower() in ['.mako']
##     dstPath = os.path.join(DST_DIR, relBase)
##     pyhpy.sync.syncMakoTemplate(data['absPath'], dstPath)
##     okDstFiles.append(dstPath)        
## def markdownFileHandler(data, DST_DIR, okDstFiles):
##     # I need to use a slightly convoluted method to produce nice results:
##     # We are given an x.md file.
##     # First, we generate an _mdParent_x.mako, which inherits from meta['inherit'] and also applies a markdown filter to the child template's body.
##     # Next, x.md file gets turned into x.mako, which inherits from _mdParent_x.mako.
##     # This enables us to use standard Mako operations (like <%def> that behave as expected).
##     #
##     # Before using this method, I tried two other approaches:
##     #   * Running a markdown filter before giving the results to mako.  This worked "OK" but was a huge pain in the ass whenever you actually needed to use mako features, due to Markdown messing with your code.
##     #   * Just using one mako template (instead of the current two) with a <%block filter="pyhpy.markdown">.  This sort of works, but the <%block> layer changes the standard Mako behavior and prevents you from using <%def> naturally.
##     #
##     base, ext = os.path.splitext(data['absPath'])
##     assert ext in ['.md']
##     dirpath, filebase = os.path.split(base)
##     assert dirpath and filebase
##     childTmplPath = base+'.mako'
##     meta = pyhpy.meta(data['absPath'])
## 
##     # Step 1: Meta
##     # If our x.md file has a x.md.meta, copy it to x.mako.meta so that our template code can always assume that the meta is available from pyhpy.meta(self.uri):
##     mdMetaPath = data['absPath']+'.meta'
##     if os.path.exists(mdMetaPath): pyhpy.sync.syncFileOrSymlink(mdMetaPath, childTmplPath+'.meta')
## 
##     # Step 2: The Parent Template:
##     parentTmplFilename = '_mdParent_'+filebase+'.mako'
##     parentTmplPath = os.path.join(dirpath, parentTmplFilename)
##     pTmpl = u'## DO NOT EDIT THIS FILE; Your changes will be lost!  This file is auto-generated from %r;  Edit that instead.\n'%(data['absPath'],)
##     if meta['inherit']: pTmpl += u'<%%inherit file="%s" />\\\n'%(meta['inherit'],)
##     pTmpl += u'<%! import pyhpy %>\\\n'
##     pTmpl += u'${capture(next.body) | pyhpy.markdown}'
##     pyhpy.sync.syncData(pTmpl, parentTmplPath)
## 
##     # Step 3: The Child Template:
##     cTmpl = u'## DO NOT EDIT THIS FILE; Your changes will be lost!  This file is auto-generated from %r;  Edit that instead.\n'%(data['absPath'],)
##     cTmpl += u'<%%inherit file="%s" />\\\n'%(parentTmplFilename,)
##     cTmpl += codecs.open(data['absPath'], encoding='utf-8').read()
##     pyhpy.sync.syncData(cTmpl, childTmplPath)
## 
##     # Finally, we need to tell the system to render the newly created child template:
##     newData = {'rootDir':data['rootDir'],
##                'absPath':childTmplPath,
##                'relPath':childTmplPath[len(data['rootDir'])+1:],
##                'mtime':data['mtime'],
##     }
##     assert newData['relPath'][0] != os.sep
##     makoFileHandler(newData, DST_DIR, okDstFiles)

def classify(SCRIPTS_DIR, ProjRelPath):
    projRelPath = ProjRelPath.lower()
    filename = os.path.split(projRelPath)[1]
    for handler in sorted(os.listdir(os.path.join(SCRIPTS_DIR,'types'))):
        match = re.match(r'^\d+-(.+?)=(.+)$', handler)   # match items like "30-filename=*.mako".
        if not match: continue
        valName, pattern = match.groups()
        assert valName in ['filename', 'path'], 'Invalid value name: %r'%(handler,)
        if fnmatch.fnmatchcase({'filename':filename, 'path':projRelPath}[valName], pattern): return os.path.realpath(os.path.join(SCRIPTS_DIR,'types',handler))
    raise ValueError('Unable to find handler for %r'%(projRelPath,))

def walkAndClassify(SCRIPTS_DIR, rootDir):
    results = {}
    for dirpath, dirnames, filenames, symlinks in pyhpy.sync.walk(rootDir):
        def projRelPath(f):
            absPath = os.path.join(dirpath, f)
            assert absPath.startswith(rootDir)
            relPath = absPath[len(rootDir):]  # Path relative to rootDir.  /path/to/root/a/b/c becomes a/b/c
            assert relPath[0] == os.sep
            relPath = relPath[1:]
            assert relPath
            return relPath
        for dirname in list(dirnames):
            handler = classify(SCRIPTS_DIR, projRelPath(dirname))
            if os.path.basename(handler).endswith('SKIP'):
                results[projRelPath(dirname)] = handler  # Even though we know we're going to skip this, call the SKIP handler anyway so that the user isn't confused when debugging.
                dirnames.remove(dirname)
        for filename in (filenames+symlinks): results[projRelPath(filename)] = classify(SCRIPTS_DIR, projRelPath(filename))
    return results
    
def build(SCRIPTS_DIR, SRC_DIR, DST_DIR):
    processed = {}
    while True:    # Support auto-generation of files/templates.  (Loop until the filesystem is stable.)
        toProcess = walkAndClassify(SCRIPTS_DIR, SRC_DIR)
        if sorted(processed) == sorted(toProcess): break
        for projRelPath,handler in sorted(toProcess.items()):
            if projRelPath in processed: continue   # Only process items once.
            retcode, cmd = 1, [handler, SRC_DIR, DST_DIR, projRelPath]
            try: retcode = subprocess.call(cmd, cwd=SRC_DIR)
            except: pass
            if retcode != 0:
                print >> sys.stderr, '\nBuild Failed!'
                print >> sys.stderr, 'There was an error while running this command: %s\n'%(' '.join(map(repr,cmd)),)
                sys.exit(retcode)
                
        processed = toProcess
    return processed

if __name__ == '__main__':
    assert len(sys.argv) == 4
    _SCRIPTS_DIR=os.path.abspath(sys.argv[1])
    _SRC_DIR=os.path.abspath(sys.argv[2])
    _DST_DIR=os.path.abspath(sys.argv[3])
    build(_SCRIPTS_DIR, _SRC_DIR, _DST_DIR)

