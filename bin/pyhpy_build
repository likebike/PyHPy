#!/usr/bin/env python

# This script publishes the input directory to the output directory in an intelligent
# way.  Copies file data & permissions & ACLs, evaluates Mako templates, ignores
# hidden files, and notifies the user of files that are in the 'output' area that
# probably shouldn't be there.
#
# Written by Christopher Sebastian, 2011-11-04

import os, sys, json, codecs
import pyhpy.sync

DOT_FILES_THAT_ARE_NOT_HIDDEN=['.htaccess']  # Dot files that we actually want
                                             # to copy.
EXTENSIONS_TO_IGNORE=['.swp', '.pyc', '.meta']

def isHiddenFile(filename):
    base, ext = os.path.splitext(filename)
    ext = ext.lower()
    if ext in EXTENSIONS_TO_IGNORE: return True
    for n in DOT_FILES_THAT_ARE_NOT_HIDDEN:
        if filename.startswith(n): return False  ## I use 'startswith' instead of '==' to handle backups of sensitive files, such as '.htaccess.bak'
    if filename[0] in '_.': return True
    if filename[-1] in '~': return True
    return False


def hiddenFileHandler(data, DST_DIR, okDstFiles):
    #print 'Skipping hidden file:',data['urlPath']
    pass
def fileOrSymlinkHandler(data, DST_DIR, okDstFiles):
    dstPath = os.path.join(DST_DIR, data['relPath'])
    pyhpy.sync.syncFileOrSymlink(data['absPath'], dstPath)
    okDstFiles.append(dstPath)
def makoFileHandler(data, DST_DIR, okDstFiles):
    relBase, relExt = os.path.splitext(data['relPath'])
    assert relExt in ['.tmpl', '.mako']
    dstPath = os.path.join(DST_DIR, relBase)
    pyhpy.sync.syncMakoTemplate(data['absPath'], dstPath)
    okDstFiles.append(dstPath)        
def markdownFileHandler(data, DST_DIR, okDstFiles):
    # I need to use a slightly convoluted method to produce nice results:
    # We are given an x.md file.
    # First, we generate an _mdParent_x.tmpl, which inherits from meta['inherit'] and also applies a markdown filter to the child template's body.
    # Next, x.md file gets turned into x.tmpl, which inherits from _mdParent_x.tmpl.
    # This enables us to use standard Mako operations (like <%def> that behave as expected).
    #
    # Before using this method, I tried two other approaches:
    #   * Running a markdown filter before giving the results to mako.  This worked "OK" but was a huge pain in the ass whenever you actually needed to use mako features, due to Markdown messing with your code.
    #   * Just using one mako template (instead of the current two) with a <%block filter="pyhpy.markdown">.  This sort of works, but the <%block> layer changes the standard Mako behavior and prevents you from using <%def> naturally.
    #
    base, ext = os.path.splitext(data['absPath'])
    assert ext in ['.md', '.markdown']
    dirpath, filebase = os.path.split(base)
    assert dirpath and filebase
    childTmplPath = base+'.tmpl'
    meta = pyhpy.meta(data['absPath'])

    # Step 1: Meta
    # If our x.md file has a x.md.meta, copy it to x.tmpl.meta so that our TMPL code can always assume that the meta is available from pyhpy.meta(self.uri):
    mdMetaPath = data['absPath']+'.meta'
    if os.path.exists(mdMetaPath): pyhpy.sync.syncFileOrSymlink(mdMetaPath, childTmplPath+'.meta')

    # Step 2: The Parent Template:
    parentTmplFilename = '_mdParent_'+filebase+'.tmpl'
    parentTmplPath = os.path.join(dirpath, parentTmplFilename)
    pTmpl = u'## DO NOT EDIT THIS FILE; Your changes will be lost!  This file is auto-generated from %r;  Edit that instead.\n'%(data['absPath'],)
    if meta['inherit']: pTmpl += u'<%%inherit file="%s" />\\\n'%(meta['inherit'],)
    pTmpl += u'<%! import pyhpy %>\\\n'
    pTmpl += u'${capture(next.body) | pyhpy.markdown}'
    pyhpy.sync.syncData(pTmpl, parentTmplPath)

    # Step 3: The Child Template:
    cTmpl = u'## DO NOT EDIT THIS FILE; Your changes will be lost!  This file is auto-generated from %r;  Edit that instead.\n'%(data['absPath'],)
    cTmpl += u'<%%inherit file="%s" />\\\n'%(parentTmplFilename,)
    cTmpl += codecs.open(data['absPath'], encoding='utf-8').read()
    pyhpy.sync.syncData(cTmpl, childTmplPath)

    # Finally, we need to tell the system to render the newly created child template:
    newData = {'rootDir':data['rootDir'],
               'absPath':childTmplPath,
               'relPath':childTmplPath[len(data['rootDir'])+1:],
               'mtime':data['mtime'],
    }
    assert newData['relPath'][0] != os.sep
    makoFileHandler(newData, DST_DIR, okDstFiles)

def walkAndClassify(rootDir):
    results = {}
    for dirpath, dirnames, filenames, symlinks in pyhpy.sync.walk(rootDir):
        for dirname in list(dirnames):
            if isHiddenFile(dirname): dirnames.remove(dirname)
        for filename in (filenames+symlinks):
            absPath = os.path.join(dirpath, filename)
            assert absPath.startswith(rootDir)
            relPath = absPath[len(rootDir):]  # Path relative to rootDir.  /path/to/root/a/b/c becomes a/b/c
            assert relPath[0] == os.sep
            relPath = relPath[1:]
            assert relPath
            data = {'rootDir':rootDir,
                    'absPath':absPath,
                    'relPath':relPath,
                    'mtime':pyhpy.getmtime(absPath),
                   }
            
            _, ext = os.path.splitext(absPath)
            if isHiddenFile(os.path.basename(absPath)):
                data['handler'] = hiddenFileHandler
            elif ext.lower() in ['.tmpl', '.mako']: data['handler'] = makoFileHandler
            elif ext.lower() in ['.md', '.markdown']: data['handler'] = markdownFileHandler
            else: data['handler'] = fileOrSymlinkHandler
            results[relPath] = data
    return results
    
def build(SRC_DIR, DST_DIR):
    okDstFiles = []
    processed, toProcess = {}, walkAndClassify(SRC_DIR)    # A simple way to support auto-generation of files/templates.  (Loop until the filesystem is stable.)
    while sorted(processed) != sorted(toProcess):
        okDstFiles = []
        for urlPath,data in sorted(toProcess.items()): data['handler'](data, DST_DIR, okDstFiles)
        processed, toProcess = toProcess, walkAndClassify(SRC_DIR)
    unexpectedDstFiles = []
    for dirpath, dirnames, filenames, symlinks in pyhpy.sync.walk(DST_DIR):
        for filename in (filenames+symlinks):
            absPath = os.path.join(dirpath, filename)
            if absPath not in okDstFiles:
                unexpectedDstFiles.append(absPath)
    return processed, unexpectedDstFiles

def main(SRC_DIR, DST_DIR):
    processed, unexpectedDstFiles = build(SRC_DIR, DST_DIR)
    for f in unexpectedDstFiles:
        if int(os.environ.get('AUTO_RM', '0')) == 1:
            print 'Auto-Removing:',f
            os.unlink(f)
        else: print 'Unexpected file in output:',f


if __name__ == '__main__':
    assert len(sys.argv) == 3
    _SRC_DIR=sys.argv[1]
    _DST_DIR=sys.argv[2]

    # print 'SRC_DIR =',_SRC_DIR
    # print 'DST_DIR =',_DST_DIR
    # print 'ACL_CHECK =',os.environ.get('ACL_CHECK', 1)
        
    main(_SRC_DIR, _DST_DIR)

