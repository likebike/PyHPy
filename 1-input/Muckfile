#!/usr/bin/env python

# Muckfiles can be written in any language.  They just need to print shell commands to stdout.
#
# Muck provides a few environment variables as inputs:
#
#     MUCK_IN_ROOT   -- The input root directory.  Example:  /path/to/proj/in
#     MUCK_OUT_ROOT  -- The output root directory. Example:  /path/to/proj/out
#     MUCK_REL_PATH  -- The file to process, relative to the MUCK_IN_ROOT.  Ex: a/b.c
#
# Muckfiles should be "functional";  For the same set of inputs,
# they should always produce the same set of outputs (shell commands).

import os, sys
from fnmatch import fnmatch

relPath = os.environ['MUCK_REL_PATH']
filename = os.path.basename(relPath)
#  Pre-calculate a few paths to make our command recipes simpler:
# (We could also calculate these things inside of the command recipes, using bash.)
inRoot, outRoot = os.environ['MUCK_IN_ROOT'], os.environ['MUCK_OUT_ROOT']
inPath = os.path.join(inRoot, os.environ['MUCK_REL_PATH'])
outPath = os.path.join(outRoot, os.environ['MUCK_REL_PATH'])
outDir = os.path.dirname(outPath)

def end(string=None):
    if string: print(string)
    sys.exit()

def mk_outdir(): print('''
{ set +x; } 2>/dev/null  # Silently disable tracing
mkdir -p %(outDir)r
set -x                   # Re-enable tracing
'''%globals())

def SKIP(verbose=False):
    if verbose: print >>sys.stderr, 'Skipping:', relPath
    sys.exit()

def ENTER_SUBDIR(): end('''
{ set +x; } 2>/dev/null  # Silently disable tracing
true                     # The command doesn't actually matter, as long as it succeeds.
echo RUNNING $MUCK_REL_PATH
find . >/dev/null
''')

def COPY():
    mk_outdir()
    end('cp --preserve=all %(inPath)r %(outPath)r'%globals())

def RSYNC():
    mk_outdir()
    end('rsync -aHAX --delete %(inPath)r/ %(outPath)r/'%globals())
    
def MAKO():
    noext, ext = os.path.splitext(relPath)    # Chop off the .mako extension.
    assert ext == '.mako'
    values = {'noext':noext}; values.update(globals())
    mk_outdir()
    end('python -m pyhpy.cmd --template-dir=%(inRoot)r --module-dir=%(inRoot)r /%(relPath)r >%(noext)r'%values)

def MARKDOWN(): end('../bin/MARKDOWN')



if relPath == 'static/lib':           RSYNC() # Copy 3rd-party libs all at once.
if relPath.startswith('static/lib/'): SKIP()  # Don't recurse into 3rd-party libs.
if os.path.isdir(relPath):            ENTER_SUBDIR()
if fnmatch(filename, '.htaccess'):    COPY()  # We want to copy these dot-files.
if fnmatch(filename, '.htpasswd'):    COPY()
if fnmatch(filename, '*.meta'):       SKIP()
if fnmatch(filename, '*.pyc'):        SKIP()
if fnmatch(filename, '*.mako.py'):    SKIP()  # Mako-generated module
if fnmatch(filename, '*.swp'):        SKIP()
if fnmatch(filename, '*~'):           SKIP()
if fnmatch(filename, '.*'):           SKIP()
if fnmatch(filename, '_*'):           SKIP()
if fnmatch(filename, '*.mako'):       MAKO()
if fnmatch(filename, '*.markdown'):   MARKDOWN()
if fnmatch(filename, '*.md'):         MARKDOWN()
if fnmatch(filename, '*'):            COPY()  # Default processor




# if fnmatch(relPath,  'static/lib'):   RSYNC()           # Don't process 3rd-party libs.   Recursion model processes this after those.  Need to re-think???
# if fnmatch(relPath,  'static/lib/*'): SKIP(silent=True) # Don't process 3rd-party libs.


#######  This is a cool idea, but I have not had a need for it yet:
# def RUN(): end('''
# chmod u+x %(inPath)r   # Automatically make the file executable.
# exec %(inPath)r
# '''%globals())

    
